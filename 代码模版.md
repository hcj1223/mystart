# 代码模版

## 小技巧

### 断链成环

```cpp
// 数组开双倍
int m = 2 * n;
for (int i = n + 1; i < m; i++)
    a[i] = a[i - n];
```

## 基础算法

### 快速排序

```c++
void quickSort(int l, int r, int a[])
{
    if (l >= r)
        return;
    int i = l - 1, j = r + 1, x = a[l + r >> 1];
    while (i < j)
    {
        do
        {
            i++;
        } while (a[i] < x);
        do
        {
            j--;
        } while (a[j] > x);
        if (i < j)
            swap(a[i], a[j]);
    }
    quickSort(l, j, a), quickSort(j + 1, r, a);
}
```

### 归并排序

```c++
void mergeSort(int l, int r, int a[])
{
    if (l >= r)
        return;
    int mid = l + r >> 1;
    mergeSort(l, mid, a), mergeSort(mid + 1, r, a);
    int i = l, j = mid + 1;
    vector<int> tmp; // 临时数组
    while (i <= mid && j <= r)
    {
        if (a[i] <= a[j])
            tmp.push_back(a[i++]);
        else
            tmp.push_back(a[j++]);
    }
    while (i <= mid)
        tmp.push_back(a[i++]);
    while (j <= r)
        tmp.push_back(a[j++]);
    for (int i = l, j = 0; i <= r; i++, j++)
        a[i] = tmp[j];
}
```

### 二分

#### 整数二分

```c++
// 向下取整
int binarySearch1(int l, int r, int x)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (a[mid] < x)
            l = mid + 1;
        else
            r = mid;
    }
    return l;
}
// 向上取整
int binarySearch2(int l, int r, int x)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (a[mid] > x)
            r = mid - 1;
        else
            l = mid;
    }
    return l;
}
```

#### 浮点数二分

```c++
double binarySearch3(double l, double r)
{
    while (r - l > 1e-8)
    {
        double mid = (l + r) / 2;
        if (check(mid))
            l = mid;
        else
            r = mid;
    }
    return l;
}
```

### 高精度

#### 加法

```c++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || i < B.size(); i++)
    {
        if (i < A.size())
            t += A[i];
        if (i < B.size())
            t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if (t)
        C.push_back(t);
    return C;
}
```

#### 减法

```c++
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i++)
    {
        t = A[i] - t;
        if (i < B.size())
            t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0)
            t = 1;
        else
            t = 0;
    }
    while (C.size() > 1 && C.back() == 0)
        C.pop_back();
    return C;
}
```

#### 乘法

```c++
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i++)
    {
        if (i < A.size())
            t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0)
        C.pop_back();
    return C;
}
```

#### 除法

```c++
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i--)
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0)
        C.pop_back();
    return C;
}
```

### 前缀和与差分

#### 一维前缀和

```c++
for (int i = 1; i <= n; i++)
    s[i] = s[i - 1] + a[i];
// a[l] + ... + a[r] = s[r] - s[l - 1]
```

#### 二维前缀和

```c++
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + g[i][j];
// 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
// s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]
```

#### 一维差分

```c++
// 给区间[l, r]中的每个数加上c
void add(int l, int r, int c)
{
    b[l] += c, b[r + 1] -= c;
}
// 初始化
for (int i = 1; i <= n; i++)
    add(i, i, a[i]);
// a[i] = b[1] + ... + b[i]
```

#### 二维差分

```c++
// 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c
void add(int x1, int y1, int x2, int y2, int c)
{
    g[x1][y1] += c, g[x2 + 1][y1] -= c, g[x1][y2 + 1] -= c, g[x2 + 1][y2 + 1] += c;
}
// 初始化
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        add(i, j, i, j, s[i][j]);
// 更新后矩阵
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1]; // s[i][j]=g[i][j]
```

### 双指针

```c++
for (int i = 0, j = 0; i < n; i++)
{
    while (...)
      	j++;
}
```

### 位运算

```c++
求n的第k位数字: n >> k & 1
返回n的最后一位1: 
int lowbit(int n)
{
  	return n & -n;
}
```

### 离散化

```c++
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); 
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去重

int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) 
          	r = mid;
        else 
          	l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

## 数据结构

### 链表

#### 单链表

```c++
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;
// 初始化
void init()
{
    head = -1, idx = 0;
}
// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```

#### 双链表

```c++
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;
// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}
// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

### 单调队列

```c++
deque<int> q;    
for (int i = 1; i <= n; i++)
{
    if (!q.empty() && i - k + 1 > q.front())
        q.pop_front();
    while (!q.empty() && a[q.back()] >= a[i])
        q.pop_back();
    q.push_back(i);
    if (i - k + 1 > 0)
        cout << a[q.front()] << " ";
}
```

### 二叉树

#### 遍历

- 先序+中序

```c++
int buildTree(int l1, int l2, int m)
{
    if (m <= 0)
        return 0;
    int root = pre[l1] - 'A' + 1;
    int p = 0;
    while (in[l2 + len] - 'A' + 1 != root)
        p++;
    lch[root] = buildTree(l1 + 1, l2, p);
    rch[root] = buildTree(l1 + p + 1, l2 + p + 1, m - p - 1);
    return root;
}
```

- 中序+后序

```c++
int buildTree(int l1, int l2, int m)
{
    if (m <= 0)
        return 0;
    int root = post[l2 + m - 1] - 'A' + 1;
    int p = 0;
    while (in[l1 + p] - 'A' + 1 != root)
        p++;
    lson[root] = buildTree(l1, l2, p);
    rson[root] = buildTree(l1 + p + 1, l2 + p, m - p - 1);
    return root;
}
```

- 先序+后序结果数

```c++
// 只有一个儿子的节点有不同的中序遍历
for (int i = 0; i < pre.size() - 1; i++)
    for (int j = 1; j < post.size(); j++)
        if (pre[i] == post[j] && pre[i + 1] == post[j - 1])
            res++;
res = 1 << res;
```

### 哈夫曼树

```c++
// 一字符串的最佳无前缀可变长度编码的长度：哈夫曼树除根节点外所有节点的值相加
if (q.size() == 1)
  	res = len;
while (q.size() > 1)
{
    int a, b;
    a = q.top(), q.pop();
    b = q.top(), q.pop();
    q.push(a + b);
    res += a + b;
}
```

### KMP

```c++
// s[]是长文本，p[]是模式串，下标从1开始
// 求模式串的next数组
for (int i = 2, j = 0; i <= n; i++)
{
    while (j && p[i] != p[j + 1])
        j = ne[j];
    if (p[i] == p[j + 1])
        j++;
    ne[i] = j;
}
// 匹配
for (int i = 1, j = 0; i <= m; i++)
{
    while (j && s[i] != p[j + 1])
        j = ne[j];
    if (s[i] == p[j + 1])
        j++;
    if (j == n)
    {
      	j = ne[j];
      	// 匹配成功
    }
}
```

### Trie树

```c++
// 高效存储和查找字符串集合
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点，cnt[]存储以每个节点结尾的单词数量，idx记录当前节点
void insert(char str[])
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u])
          	son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}
int query(char str[])
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u])
          	return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

### 并查集

```c++
int p[N]; // 存储每个点的祖宗节点
int size[N]; // 存储祖宗节点所在集合中的点的数量
int d[N]; // d[x]存储x到p[x]的距离
int find(int x) // 返回x的祖宗节点
{
    if (p[x] != x) 
    {
      	d[x] += d[p[x];
      	p[x] = find(p[x]);
    }
    return p[x];
}
for (int i = 1; i <= n; i ++ ) // 初始化，假定节点编号是1~n
  	p[i] = i, size[i] = 1, d[i] = 0;
size[find(b)] += size[find(a)], p[find(a)] = find(b); // 合并a和b所在的两个集合
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

### 堆

```c++
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x+1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中第k个点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}
void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) 
      	t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) 
      	t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}
void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}
// O(n)建堆
for (int i = n / 2; i; i -- ) 
  	down(i);
void push(int x)
{
		h[++size] = x;
  	up(size);
}
void pop()
{
  	heap_swap(1, size);
  	size--;
  	down(1);
}
```

### 一般哈希

#### 拉链法

```c++
int h[N], e[N], ne[N], idx;
void insert(int x) // 向哈希表中插入一个数
{
    int k = (x % N + N) % N;
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx ++ ;
}
bool find(int x) // 在哈希表中查询某个数是否存在
{
    int k = (x % N + N) % N;
    for (int i = h[k]; i != -1; i = ne[i])
        if (e[i] == x)
            return true;
    return false;
}
```

#### 开放寻址法

```c++
int h[N];
// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
int find(int x)
{
    int t = (x % N + N) % N;
    while (h[t] != null && h[t] != x)
    {
        t ++ ;
        if (t == N) 
          	t = 0;
    }
    return t;
}
```

## 图论

### 邻接表

```c++
int h[N], e[N], ne[N], idx;
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

### DFS

```c++
int dfs(int u)
{
    st[u] = true;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) 
          	dfs(j);
    }
}
```

### BFS

```c++
queue<int> q;
st[1] = true;
q.push(1);
while (!q.empty())
{
    int t = q.front();
    q.pop();
    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            q.push(j);
        }
    }
}
```

### 拓扑排序

```c++
bool topsort()
{
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i ++ )
        if (!d[i]) // d[i]存储点i的入度
            q[++tt] = i;
    while (hh <= tt)
    {
        int t = q[hh++];
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (--d[j] == 0)
                q[++tt] = j;
        }
    }
    return tt == n - 1;
}
```

### 最短路径

#### 朴素Dijkstra

```c++
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        st[t] = true;
    }
    if (dist[n] == 0x3f3f3f3f) 
      	return -1;
    return dist[n];
}
```

#### 堆优化Dijkstra

```c++
typedef pair<int, int> PII;
int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1}); // first存储距离，second存储节点编号
    while (!heap.empty())
    {
        auto t = heap.top();
        heap.pop();
        int ver = t.second, distance = t.first;
        if (st[ver]) 
          	continue;
        st[ver] = true;
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) 
      	return -1;
    return dist[n];
}
```

#### Bellman-Ford

```c++
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离
struct Edge
{
    int a, b, w;
}edges[M];
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }
    if (dist[n] > 0x3f3f3f3f / 2) 
      	return -1;
    return dist[n];
}
```

#### SPFA

```c++
// 队列优化的Bellman-Ford算法
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue<int> q;
    q.push(1);
    st[1] = true;
    while (!q.empty())
    {
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f)
      	return -1;
    return dist[n];
}
```

#### Floyd

```c++
// 初始化
for (int i = 1; i <= n; i ++ )
    for (int j = 1; j <= n; j ++ )
        if (i == j) 
          	d[i][j] = 0;
        else d[i][j] = 0x3f3f3f3f;
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

### 最小生成树

#### Prim

```c++
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中
int prim() // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
{
    memset(dist, 0x3f, sizeof dist);
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        if (i && dist[t] == 0x3f3f3f3f)
          	return 0x3f3f3f3f;
        if (i) 
          	res += dist[t];
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) 
          	dist[j] = min(dist[j], g[t][j]);
    }
    return res;
}
```

#### Kruskal

```c++
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组
struct Edge     // 存储边
{
    int a, b, w;
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
int find(int x)     // 并查集核心操作
{
    if (p[x] != x) 
      	p[x] = find(p[x]);
    return p[x];
}
int kruskal()
{
    sort(edges, edges + m);
    for (int i = 1; i <= n; i ++ ) 
      	p[i] = i;    // 初始化并查集
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
    if (cnt < n - 1) 
      	return 0x3f3f3f3f;
    return res;
}
```

### 二分图

#### 染色法

```c++
// 判断二分图
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色
bool dfs(int u, int c) // 参数：u表示当前节点，c表示当前点的颜色
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
            if (!dfs(j, !c)) 
              	return false;
        else if (color[j] == c) 
          	return false;
    }
    return true;
}
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

#### 匈牙利算法

```c++
// 求二分图的最大匹配
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j])) // 没匹配或匹配对象能找到下家
            {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}
// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) 
      	res ++ ;
}
```

## 数学知识

### 质数

#### 判定质数

```c++
bool is_prime(int x)
{
    if (x < 2) 
      	return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```

#### 分解质因数

```c++
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) 
              	x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) 
      	cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

#### 筛质数

```c++
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉
void get_primes(int n) // 线性筛
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) 
          	primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0)  // primes[j]是i的最小质因子
              	break;
        }
    }
}
```

### 约数

#### 求所有约数

```c++
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) 
              	res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```

#### 约数个数及约数之和

```latex
如果 N = p1^c1 * p2^c2 * ... * pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)
```

#### 求最大公约数

```c++
// 欧几里得算法
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

### 欧拉函数

```c++
// 欧拉函数e(n)表示为1～n中与n互质的数的个数
// 如果 N = p1^c1 * p2^c2 * ... * pk^ck
// 则 e(n) = N * (1 - 1/p1) * ... * (1 - 1/pk)
int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];             // st[x]存储x是否被筛掉
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1; // 质数的欧拉函数
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {   // 当 i % primes[j] == 0 时，e(i * primes[j]) = primes[j] * e(i)
                euler[t] = euler[i] * primes[j];
                break;
            }
          	// 当 i % primes[j] != 0 时，e(i * primes[j]) = primes[j] * e(i) * (1 - 1/pj)
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```

### 快速幂

```c++
int qmi(int a, int k, int p) // 求 a^k % p
{
  	int res = 1;
    while (k)
    {
      	if (k & 1)
          	res = (long long)res * a % p;
     		k >>= 1;
      	a = (long long)a * a % p;
    }
    return res;
}
```

### 扩展欧几里得算法

```c++
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
  	// b*y + (a%b)*x = gcd(a, b) =>
  	// b*y + (a-a/b*b)*x = ax + b[y-(a/b)*x] = gcd(a, b)
    y -= (a / b) * x;
    return d;
}
```

### 高斯消元

```c++
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) // 找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) 
          	continue;
        for (int i = c; i <= n; i ++ ) // 将绝对值最大的行换到最顶端
          	swap(a[t][i], a[r][i]);
        for (int i = n; i >= c; i -- ) // 将当前行的首位变成1
          	a[r][i] /= a[r][c];      
        for (int i = r + 1; i < n; i ++ ) // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
        r++;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1; // 有无穷多组解
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; // 有唯一解
}
```

### 组合数

#### 递归求组合数

```c++
int C(int n, int m)
{
    if (n == m || m == 0) 
      	return 1;
    return C(n, m - 1) * (n - m + 1) / m;
}
```

#### 动态规划求组合数

```c++
int C(int n, int m)
{
    if (n == m || m == 0) 
      	return 1;
    vector<int> dp(m+1);
    for (int i = 0; i <= n; i++)
        for (int j = min(i, m); j >= 0; j--)
            if (i == j || j == 0) 
              	dp[j] = 1;
            else 
              	dp[j] = dp[j] + dp[j-1];
    return dp[m];
}
```

#### 正向递推求组合数

```c++
int C(int n, int m)
{
    if (n == m || m == 0) 
      	return 1;
    int ans = 1;
    m = min(m, n - m);
    for (int i = 1; i <= m; i++) 
      	ans = ans * (n - i + 1) / i;
    return ans;
}
```

#### 卡特兰数

```txt
给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Catalan(n) = C(2n, n) / (n + 1)
```

## 动态规划

```txt
DP:
1.状态表示：化零为整
- 1.1.集合：所有满足...条件的方案的集合
- 1.2.属性：MAX/MIN/数量/...
2.状态计算：划分最后一个不同点（不重不漏）

时间复杂度：状态*转移
```

### 背包问题

#### 01背包

```c++
for (int i = 1; i <= n; i++)
    for (int j = 0; j <= m; j++)
    {
        f[i][j] = f[i - 1][j];
        if (j >= v[i])
            f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
    }
// 优化成一维
for (int i = 1; i <= n; i++)
    for (int j = m; j >= v[i]; j--)
    		f[j] = max(f[j], f[j - v[i]] + w[i]);
```

#### 完全背包

```c++
/*
    f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w, ...)
    f[i][j - v] = max(f[i - 1][j - v], f[i - 1][j - 2v] + w, ...)
 => f[i][j] = max(f[i - 1][j], f[i][j - v] + w)
*/
for (int i = 1; i <= n; i++)
    for (int j = 0; j <= m; j++)
    {
        f[i][j] = f[i - 1][j];
        if (j >= v[i])
            f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
    }
// 优化成一维
for (int i = 1; i <= n; i++)
    for (int j = v[i]; j <= m; j++)
    		f[j] = max(f[j], f[j - v[i]] + w[i]);
```

#### 多重背包

```c++
for (int i = 1; i <= n; i++)
    for (int j = 0; j <= m; j++)
        for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
            f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
// 二进制优化，将s分为1,2,4,8,...的堆，转化为每个堆取不取的01背包问题
int cnt = 0;
for (int i = 1; i <= n; i++)
{
    int k = 1;
    while (k <= S[i])
    {
        cnt++;
        v[cnt] = V[i] * k, w[cnt] = W[i] * k; // v[], w[]的大小为N*logS
        S[i] -= k;
        k *= 2; // 分成1，2，4，8，...
    }
    if (S[i])
    {
        cnt++;
        v[cnt] = V[i] * S[i], w[cnt] = W[i] * S[i];
    }
}
for (int i = 1; i <= cnt; i++) // 转化为取不取该堆的01背包问题
    for (int j = m; j >= v[i]; j--)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```

#### 分组背包

```c++
for (int i = 1; i <= n; i++)
    for (int j = 0; j <= m; j++)
        for (int k = 0; k <= S[i]; k++)
            if (j >= v[i][k])
                f[i][j] = max(f[i][j], f[i - 1][j - v[i][k]] + w[i][k]);
// 优化成一维
for (int i = 1; i <= n; i++)
    for (int j = m; j >= 0; j--)
        for (int k = 0; k <= S[i]; k++)
            if (j >= v[i][k])
                f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
```

### 线性DP

#### 最长上升子序列

```c++
// 状态转移：子序列中第i个数之前的数的序号是1, 2, ... , i-1
for (int i = 1; i <= n; i++)
{
    f[i] = 1;
    for (int j = 1; j < i; j++)
        if (a[j] < a[i])
            f[i] = max(f[i], f[j] + 1);
}
```

#### 最长公共子序列

```c++
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
    {
        f[i][j] = max(f[i - 1][j], f[i][j - 1]);
        if (a[i] == b[j])
            f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
    }
```

#### 最短编辑距离

```c++
for (int i = 0; i <= m; i++)
    f[0][i] = i;
for (int i = 0; i <= n; i++)
    f[i][0] = i;
// 1.增 2.删 3.改
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
    {
        f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1);
        if (a[i] == b[j])
            f[i][j] = min(f[i][j], f[i - 1][j - 1]);
        else
            f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);
    }
```

### 区间DP

```c++
/*
		f[i][j] - 集合：所有将区间[i, j]合并成一堆的方案的集合
   			    - 转移：[i, j]中的分界点
*/
for (int len = 2; len <= n; len++)
    for (int i = 1; i + len - 1 <= n; i++)
    {
        int j = i + len - 1;
        f[i][j] = 1e8;
        for (int k = i; k < j; k++)
            f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]);
    }
```

### 计数类DP

#### 整数划分

```c++
/* 
		完全背包：
				f[i][j] - 集合：所有1～i的数字的取法中正好等于j的方案的集合
								- 属性：数量
								- 转移：数字i的选取个数
		f[i][j]   = f[i-1][j] + f[i-1][j-i] + f[i-1][j-i*2] + ... + f[i-1][j-i*s]
		f[i][j-i] =             f[i-1][j-i] + f[i-1][j-i*2] + ... + f[i-1][j-i*s]（f[i-1][j-i*(s+1)]不存在）
 => f[i][j]   = f[i-1][j] + f[i][j-i]
 => f[j]      = f[j] + f[j-i]
*/
f[0] = 1;
for (int i = 1; i <= n; i++)
    for (int j = i; j <= n; j++)
        f[j] = f[j] + f[j - i];
/*
		f[i][j] - 集合：所有总和为i且恰好表示成j个（不同）数的和的方案的集合
		 				- 转移：j个数的最小值为1｜j个数的最小值大于1
		f[i][j] = f[i-1][j-1] + f[i-j][j]（每个数都减1）
*/
f[0][0] = 1;
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j++)
        f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod;
// res = f[n][1~n]
```

### 数位统计DP

### 状态压缩DP

### 树形DP

